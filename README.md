# Minimal React Boilerplate

This is a very minimal set-up to get started writing a React app. It bundles your code using [Parcel](https://parceljs.org) and has [Jest](https://jestjs.io/) configured to write tests with [react-testing-library](https://github.com/kentcdodds/react-testing-library).

## Weird stuff

### Jest set-up

Parcel [handles imports of non-JS assets](https://parceljs.org/assets.html) like styles (`.css`/`.scss` etc) and files (`.svg`, `.ttf` etc). Unfortunately Jest doesn't understand these imports, so we need to mock them.

There's a `"jest"` field in the `package.json` that configures this:

```json
"jest": {
  "moduleNameMapper": {
    "\\.(css|less|sass|scss)$": "<rootDir>/__mocks__/styleMock.js",
    "\\.(gif|ttf|eot|svg)$": "<rootDir>/__mocks__/fileMock.js"
  }
}
```

This tells Jest to use our own styleMock file when it encounters an import for any style file, and our fileMock file when it imports image/font files. You can adjust this to support whatever file extensions you need.

The mock files themselves are in the `__mocks__` directory, and export a basic version of what Parcel would produce—a string for a file import or an empty object for a style import. This is just enough to ensure Jest won't throw an error when it encounters an `import './style.css` in your JS.

### ESLint set-up

The `.eslintrc.json` specifies the `babel-eslint` parser, which allows ESLint to understand the JSX/ES6+ syntax we'll be writing.

We're also using the rules from the regular recommended preset and the React one. We've disabled a single rule—the React prop-types one, since we won't be using those.

We also configured the environments ESLint should use to "browser" and "jest". This will tell ESLint that certain globals exist and that it shouldn't flag them as undefined (e.g `document` for the browser or `test` for Jest).

### .gitignore

The `.gitignore` ensures the files generated by Parcel (anything in `dist/` or `.cache/`) on each build don't get put into source-control, since they'll change every time you edit any code.

## How Parcel works

We want to be able to write modular code using the ES Modules import/export syntax. We also want to be able to write modern ES6+ and custom React syntax (JSX).

Since browsers don't understand these things we need something to process our source files, transpile them with Babel and then bundle them together into files the browser understands.

Parcel automatically uses the babel-preset-env and babel-preset-react presets to transpile ES6 and JSX. We've also added the babel-plugin-transform-class-properties(https://babeljs.io/docs/plugins/transform-class-properties/) plugin so we can write our class state without needing a constructor function.

Your start script (parcel index.html) will tell Parcel to use the index.html file as an 'entrypoint'.

This means Parcel will start there, find your JS file linked in a script tag, then follow the trail of imports until it has built up a 'tree' of your entire app.

Then it smushes all the files together in a smart way until it's left with a single JS file.

It copies your index.html file into a dist folder, along with the newly bundled JS file (which it also links in the new index.html for you).

If you import CSS or SVGs (or other resources Parcel understands) they'll get picked up too. The CSS will all be smushed together into one file and copied into the dist folder. Any SVG files will be copied across as they are (although they will get a hashed filename for caching purposes).

You can open up the dist folder and look around. The JS Parcel produces will be weird (it has to use lots of IIFEs and closures to ensure modules are isolated correctly inside one big file) but it should be readable.
